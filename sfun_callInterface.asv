function sfun_callInterface(block)
    % 初始化 S-Function
    setup(block);
end

% ─────────────────── SETUP ────────────────────
function setup(block)
    % I/O 配置（没有输入端口）
    block.NumInputPorts  = 0;
    block.NumOutputPorts = 1;
    block.OutputPort(1).Dimensions       = 1;
    block.OutputPort(1).DatatypeID       = 0;  % 输出一个常数，作为标志位

    % 明确设置输出端口的采样模式（设置为样本数据）
    block.OutputPort(1).SamplingMode = 'Sample';  % FRAME_NO: 样本数据

    % SampleTime 配置
    block.SampleTimes        = [0 0];         % 立即执行，停止仿真时使用
    block.SimStateCompliance = 'DefaultSimState';

    % 注册方法
    block.RegBlockMethod('PostPropagationSetup', @PostProp);
    block.RegBlockMethod('InitializeConditions', @InitCond);
    block.RegBlockMethod('Outputs', @Outputs);
    block.RegBlockMethod('Terminate', @Terminate);

    % 设置 OpenFcn 触发 GUI
    set_param(block.BlockHandle, 'OpenFcn', 'start_import_gui');
end

% ─── PostPropagationSetup：声明 DWork ───
function PostProp(block)
    block.NumDworks = 3;
    
    % Dwork 1: 用于存储 GUI 是否已启动的标志
    block.Dwork(1).Name            = 'guiLaunched';
    block.Dwork(1).Dimensions      = 1;
    block.Dwork(1).DatatypeID      = 0;
    block.Dwork(1).Complexity      = 'Real';
    block.Dwork(1).UsedAsDiscState = true;
    
    % Dwork 2: 用于存储确认标志
    block.Dwork(2).Name            = 'confirmationFlag';
    block.Dwork(2).Dimensions      = 1;
    block.Dwork(2).DatatypeID      = 0;
    block.Dwork(2).Complexity      = 'Real';
    block.Dwork(2).UsedAsDiscState = true;

    % Dwork 3: 用于存储是否已尝试启动仿真的标志（防止多次调用）
    block.Dwork(3).Name            = 'simStarted';
    block.Dwork(3).Dimensions      = 1;
    block.Dwork(3).DatatypeID      = 0;
    block.Dwork(3).Complexity      = 'Real';
    block.Dwork(3).UsedAsDiscState = true;
end

% ─── InitializeConditions：初始化 DWork ───
function InitCond(block)
    % 每次仿真开始时重置标志
    block.Dwork(1).Data = 0;  % GUI 未启动
    block.Dwork(2).Data = 0;  % 确认标志为 0
    block.Dwork(3).Data = 0;  % 未启动仿真
end

% ─── Outputs ───
function Outputs(block)
    % 获取当前状态
    guiLaunched = block.Dwork(1).Data;
    confirmationFlag = block.Dwork(2).Data;
    simStarted = block.Dwork(3).Data;
    
    % 如果 GUI 尚未启动，则启动 GUI
    if guiLaunched == 0
        % 在这里获取模型名称，此时 block.BlockHandle 是有效的
        modelName = bdroot(block.BlockHandle); 
        start_import_gui(modelName);  % 传递块句柄给 GUI
        block.Dwork(1).Data = 1;  % 设置 GUI 已启动标志
    end
    
    % 尝试从基础工作空间获取确认状态
    try
        confirmationFlag = evalin('base', 'confirmationFlag');
        block.Dwork(2).Data = confirmationFlag;
    catch
        % 如果变量不存在，保持当前值
    end
    
    % 输出确认标志
    block.OutputPort(1).Data = confirmationFlag;
    
    % 如果确认标志是 1，且尚未启动仿真，则自动运行仿真
    if confirmationFlag == 1 && simStarted == 0
        % 自动开始仿真，无需手动输入
        set_param(bdroot(block.BlockHandle), 'SimulationCommand', 'start');
        block.Dwork(3).Data = 1;  % 设置已启动标志
    end

    % 如果确认标志是 -1，表示取消，停止仿真
    if confirmationFlag == -1
        try
            % 检查仿真是否正在运行，若正在运行则停止
            simStatus = get_param(bdroot(block.BlockHandle), 'SimulationStatus');
            if strcmp(simStatus, 'running')
                % 如果仿真正在运行，取消仿真
                set_param(bdroot(block.BlockHandle), 'SimulationCommand', 'stop');
                disp('仿真已取消');
            end
        catch
            % 如果没有仿真，或其他错误，则跳过
            disp('未能检查到正在运行的仿真，或仿真未启动');
        end
    end
end

% ─── Terminate：处理进程退出 ───
function Terminate(~)
    % 清理基础工作空间中的标志变量
    evalin('base', 'clear confirmationFlag');
end

function start_import_gui(modelName)
    % 获取屏幕大小
    screenSize = get(0, 'ScreenSize');
    screenWidth = screenSize(3);
    screenHeight = screenSize(4);
    
    % 设置图形界面大小
    figWidth = 800;
    figHeight = 400;

    % 计算居中显示的坐标
    figPosX = (screenWidth - figWidth) / 2;
    figPosY = (screenHeight - figHeight) / 2;

    % 创建图形界面（窗口），居中显示
    fig = uifigure('Name', '数据导入与显示', 'Position', [figPosX, figPosY, figWidth, figHeight], ...
                   'CloseRequestFcn', @(src, event) close_gui(fig));

    % 存储块句柄在图形对象的 UserData 中
    fig.UserData.modelName  = modelName;

    % 加载 DLL（在 GUI 启动时加载一次）
    dll = fullfile(pwd, 'bin', 'BWIBridgeDLL.dll');
    hdr = fullfile(pwd, 'bin', 'BWIBridgeDLL.h');
    if ~libisloaded('BWIBridgeDLL')
        loadlibrary(dll, hdr);
    end
    fig.UserData.dllLoaded = true;  % 标记 DLL 已加载

    % 创建按钮来导入数据
    btnImport = uibutton(fig, 'push', 'Text', '导入数据', 'Position', [680, 360, 100, 30], ...
                         'ButtonPushedFcn', @(src, event) import_data(fig));

    % 创建一个uitable用于显示数据
    uit = uitable(fig, 'Position', [20, 60, 760, 280], ...
                  'ColumnName', {'变量名', '数值', '最小值', '最大值', '说明'}, ...
                  'Data', {}, 'ColumnEditable', [false true false false false]);
    uit.Tag = 'dataTable';  % 设置标签，方便后续操作

    % 用于保存数据的临时变量（移到 fig.UserData）
    fig.UserData.data = [];
    fig.UserData.originalData = [];  % 用于存储原始数据

    % 创建一个TextArea来显示文件夹路径
    filePathLabel = uilabel(fig, 'Text', '选择的文件夹路径：', 'Position', [20, 360, 100, 30]);
    filePathTextArea = uitextarea(fig, 'Position', [130, 360, 530, 30], 'Tag', 'filePathTextArea');
    filePathTextArea.Editable = 'off';  % 设置为只读

    % 创建"确认"按钮
    uibutton(fig, 'push', 'Text', '确认', 'Position', [520, 20, 100, 30], ...
             'ButtonPushedFcn', @(src, event) confirm_action(fig));

    % 创建"取消"按钮
    uibutton(fig, 'push', 'Text', '取消', 'Position', [640, 20, 100, 30], ...
             'ButtonPushedFcn', @(src, event) cancel_action(fig));
end

% 导入数据的回调函数
function import_data(fig)
    % 弹出文件夹选择对话框
    folderPath = uigetdir('', '选择数据文件夹');
    
    if folderPath == 0  % 用户取消选择文件夹
        return;
    end

    % 拼接完整路径
    iniFilePath = fullfile(folderPath, 'bwiparamtemp.ini');
    
    if ~isfile(iniFilePath)
        uialert(fig, 'bwiparamtemp.ini 文件不存在', '导入错误');
        return;
    end
    
    % 调用 DLL 读取数据
    try
        % 创建处理器
        proc = calllib('BWIBridgeDLL', 'CreateProcessor');
        
        % 调用函数加载 INI 参数
        calllib('BWIBridgeDLL', 'LoadParametersFromIni', proc, iniFilePath);
        
        % 获取参数数量
        paramCount = calllib('BWIBridgeDLL', 'GetGlobalParameterCount', proc);
        
        % 获取参数的名称、数值、最小值、最大值、描述等
        data = cell(paramCount, 5);  % 5 列：名称、数值、最小值、最大值、描述
        for i = 0:paramCount-1
            name = calllib('BWIBridgeDLL', 'GetParameterName', proc, i);
            value = calllib('BWIBridgeDLL', 'GetParameterValue', proc, i);
            minVal = calllib('BWIBridgeDLL', 'GetParameterMin', proc, i);
            maxVal = calllib('BWIBridgeDLL', 'GetParameterMax', proc, i);
            desc = calllib('BWIBridgeDLL', 'GetParameterDescription', proc, i);
            
            % 假设 value, minVal, maxVal 是 double，确保一致
            data{i+1, 1} = char(name);      % 变量名 (确保字符串)
            data{i+1, 2} = value;           % 数值 (double)
            data{i+1, 3} = minVal;          % 最小值 (double)
            data{i+1, 4} = maxVal;          % 最大值 (double)
            data{i+1, 5} = char(desc);      % 说明 (确保字符串)
        end
        
        % 更新表格数据
        uit = findobj(fig, 'Tag', 'dataTable');
        uit.Data = data;  % 显示数据
        
        % 保存数据到 fig.UserData（原始数据和当前数据）
        fig.UserData.data = data;
        fig.UserData.originalData = data;  % 存储原始数据副本

        % 更新文件夹路径显示框
        filePathTextArea = findobj(fig, 'Tag', 'filePathTextArea');
        if ~isempty(filePathTextArea)
            filePathTextArea.Value = {folderPath};  % 显示路径 (uitextarea Value 是 cell)
        else
            uialert(fig, '未找到文件夹路径文本框，无法更新路径', '更新错误');
        end
        
        % 释放处理器
        calllib('BWIBridgeDLL', 'DeleteProcessor', proc);
        
        disp('数据导入成功');
    catch ME
        % 读取文件失败时的处理
        uialert(fig, ['文件导入失败: ', ME.message], '导入错误');
    end
end

% 确认按钮的回调
function confirm_action(fig)
    % 获取表格数据
    uit = findobj(fig, 'Tag', 'dataTable');
    data = uit.Data;  % 表格中的所有数据

    % 获取文件夹路径作为项目路径
    filePathTextArea = findobj(fig, 'Tag', 'filePathTextArea');
    folderPath = filePathTextArea.Value{1};  % 获取显示的文件夹路径 (从 cell 取)
    
    if isempty(folderPath)
        uialert(fig, '文件夹路径无效', '导入错误');
        return;
    end

    % 确保将 folderPath 转换为字符向量
    folderPath = char(folderPath);

    % 创建处理器
    proc = calllib('BWIBridgeDLL', 'CreateProcessor');

    % 获取原始数据从 fig.UserData
    originalData = fig.UserData.originalData;
    
    % 如果没有原始数据，则使用当前数据作为原始数据
    if isempty(originalData)
        originalData = data;
        fig.UserData.originalData = data;
    end
    
    % 遍历表格中的每一行，获取参数名和新值
    updated = false;  % 标记是否有更新
    for i = 1:size(data, 1)
        paramName = data{i, 1};   % 参数名
        newValue = data{i, 2};    % 修改后的新值
        
        % 确保 paramName 转换为字符向量
        paramName = char(paramName);
        
        % 确保 newValue 是数值类型 (表格编辑可能返回 char)
        if ischar(newValue) || iscell(newValue)
            newValue = str2double(newValue);
        end
        if isnan(newValue)
            uialert(fig, ['参数 ', paramName, ' 的值无效（非数值）'], '导入错误');
            calllib('BWIBridgeDLL', 'DeleteProcessor', proc);
            return;
        end
        
        % 获取原始值
        originalValue = originalData{i, 2};
        
        % 检查值是否发生变化
        if isequal(newValue, originalValue)
            disp(['参数 ', paramName, ' 未发生变化，跳过更新']);
            continue; % 跳过这个参数
        end
        
        % 更新参数
        result = calllib('BWIBridgeDLL', 'RewriteBWIIni_Param', proc, paramName, newValue, folderPath);
        
        % 检查更新是否成功
        if result
            disp(['参数 ', paramName, ' 修改成功']);
            % 更新原始数据
            originalData{i, 2} = newValue;
            updated = true;
        else
            uialert(fig, ['参数 ', paramName, ' 修改失败'], '导入错误');
            calllib('BWIBridgeDLL', 'DeleteProcessor', proc);
            return;
        end
    end
    
    % 更新原始数据
    fig.UserData.originalData = originalData;

    try
        blockHandle = fig.UserData.blockHandle;
        modelName = bdroot(blockHandle); % 获取顶层模型的名称
        
        % 设置 sfun_callBWIS 模块的路径参数
        set_param([modelName, '/BWIS_Launcher'], 'paramPath', folderPath);
        
        % 设置 sfun_callBWISProcess 模块的路径参数
        set_param([modelName, '/BWIS_Processor'], 'dataDir', folderPath);
        
        disp('已成功将路径参数传递到后续模块。');
    catch ME
        uialert(fig, ['无法设置后续模块的路径参数: ', ME.message], '参数传递错误');
        % 释放处理器并返回，防止在出错时继续执行
        calllib('BWIBridgeDLL', 'DeleteProcessor', proc);
        return;
    end
    
    % 释放处理器
    calllib('BWIBridgeDLL', 'DeleteProcessor', proc);
    
    % 在基础工作空间中设置确认标志为 1
    assignin('base', 'confirmationFlag', 1);
    
    % 关闭 GUI 窗口
    delete(fig);
end

% 取消按钮的回调
function cancel_action(fig)
    % 在基础工作空间中设置确认标志为 -1
    assignin('base', 'confirmationFlag', -1);
    
    % 关闭 GUI 窗口
    delete(fig);
end

% GUI 关闭回调函数
function close_gui(fig)
    % 卸载 DLL 如果已加载
    if isfield(fig.UserData, 'dllLoaded') && fig.UserData.dllLoaded && libisloaded('BWIBridgeDLL')
        unloadlibrary('BWIBridgeDLL');
    end
    % 清理其他资源如果需要
    delete(fig);
end